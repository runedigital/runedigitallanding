<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RUNE // PRECRIME INTERFACE</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        
        /* THE UI OVERLAY */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 40px; box-sizing: border-box;
        }

        .hud-text { color: #00aaff; text-shadow: 0 0 5px #00aaff; font-weight: bold; letter-spacing: 2px; }
        .big-text { font-size: 2rem; }
        
        /* HIDDEN VIDEO FEED */
        video { position: absolute; width: 640px; height: 480px; opacity: 0; pointer-events: none; }
        
        /* THE CANVAS (Visuals) */
        canvas { 
            display: block; 
            transform: scaleX(-1); /* Mirror Mode */
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-text">
            <div>SYSTEM: PRECRIME_BETA</div>
            <div id="coords">XYZ: 000 / 000</div>
        </div>
        <div class="hud-text" style="text-align: center;">
            <div id="timeline-label" class="big-text">TIMELINE: A</div>
        </div>
        <div class="hud-text" style="display:flex; justify-content: space-between;">
            <div>GESTURE_RECOGNITION: ACTIVE</div>
            <div>V. 1.0.4</div>
        </div>
    </div>

    <video id="video" autoplay playsinline></video>
    <canvas id="canvas"></canvas>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // SYSTEM VARS
        let width, height;
        let particles = []; 
        const particleCount = 2000; // The "Ghost Hand" density
        
        // TRACKING VARS (The "Centroid")
        let cx = 0; // Target X
        let cy = 0; // Target Y
        let sx = 0; // Smoothed X
        let sy = 0; // Smoothed Y
        
        // ANALYSIS
        const resX = 64; const resY = 48;
        const tmpCanvas = document.createElement('canvas');
        const tmpCtx = tmpCanvas.getContext('2d');
        tmpCanvas.width = resX; tmpCanvas.height = resY;
        let prevFrame = null;

        // APP STATE
        let timelinePos = 0.5; // 0.0 to 1.0
        let scaleVal = 1.0;    // 0.5 to 2.0

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                video.srcObject = stream;
                video.onloadedmetadata = () => { video.play(); init(); };
            } catch (e) { alert("Camera Needed for Gesture Control"); }
        }

        function init() {
            resize();
            for(let i=0; i<particleCount; i++) particles[i] = { x: -100, y: -100, life: 0 };
            animate();
        }

        function detectMotion() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                tmpCtx.drawImage(video, 0, 0, resX, resY);
                const currentFrame = tmpCtx.getImageData(0, 0, resX, resY).data;
                
                let totalX = 0;
                let totalY = 0;
                let activeCount = 0;

                if (prevFrame) {
                    for (let y = 0; y < resY; y++) {
                        for (let x = 0; x < resX; x++) {
                            const i = (y * resX + x) * 4;
                            const diff = Math.abs(currentFrame[i+1] - prevFrame[i+1]); 
                            
                            if (diff > 25) {
                                const screenX = (x / resX) * width;
                                const screenY = (y / resY) * height;
                                spawnGhost(screenX, screenY);
                                
                                // Accumulate for Centroid
                                totalX += screenX;
                                totalY += screenY;
                                activeCount++;
                            }
                        }
                    }
                }
                
                // CALCULATE CENTROID (Average Position of Movement)
                if (activeCount > 10) {
                    cx = totalX / activeCount;
                    cy = totalY / activeCount;
                }

                prevFrame = currentFrame;
            }
        }

        function spawnGhost(x, y) {
            for(let i=0; i<particles.length; i++) {
                if(particles[i].life <= 0) {
                    particles[i].x = x + (Math.random()-0.5)*20;
                    particles[i].y = y + (Math.random()-0.5)*20;
                    particles[i].life = 5; // Short life for snappy tracking
                    return;
                }
            }
        }

        function animate() {
            // 1. DARK GLASS BACKGROUND
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, width, height);
            
            detectMotion();

            // 2. SMOOTHING (LERP) - Makes the controls feel heavy/premium
            sx += (cx - sx) * 0.1;
            sy += (cy - sy) * 0.1;

            // 3. UPDATE LOGIC
            timelinePos = sx / width; // X controls Timeline
            scaleVal = 1 + (1 - (sy / height)); // Y controls Scale (Up = Bigger)

            // Update HUD Text
            document.getElementById('coords').innerText = `XYZ: ${Math.floor(sx)} / ${Math.floor(sy)}`;
            
            const label = document.getElementById('timeline-label');
            if (timelinePos < 0.33) { label.innerText = "TIMELINE: ALPHA"; label.style.color = "#00ffea"; }
            else if (timelinePos < 0.66) { label.innerText = "TIMELINE: BETA"; label.style.color = "#ffffff"; }
            else { label.innerText = "TIMELINE: OMEGA"; label.style.color = "#ff0055"; }

            // 4. DRAW THE GHOST HAND (Your Digital Spirit)
            ctx.fillStyle = 'rgba(0, 170, 255, 0.3)';
            particles.forEach(p => {
                if(p.life > 0) {
                    p.life--;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
                    ctx.fill();
                }
            });

            // 5. DRAW THE UI (Controlled by Ghost Hand)
            
            // A. The Timeline Track (Bottom)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(50, height - 100);
            ctx.lineTo(width - 50, height - 100);
            ctx.stroke();

            // B. The Timeline Handle (Follows X)
            const handleX = sx; // Locked to smoothed X
            ctx.fillStyle = label.style.color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = ctx.fillStyle;
            ctx.fillRect(handleX - 10, height - 120, 20, 40);
            ctx.shadowBlur = 0;

            // C. The Data Window (Center - Follows Scale)
            const baseSize = 300;
            const currentSize = baseSize * scaleVal;
            
            ctx.save();
            ctx.translate(width/2, height/2);
            
            // Draw Window Frame
            ctx.strokeStyle = label.style.color; // Matches timeline color
            ctx.lineWidth = 2;
            ctx.strokeRect(-currentSize/2, -currentSize/2, currentSize, currentSize);
            
            // Decorative "Minority Report" Corners
            const corner = 20;
            ctx.lineWidth = 6;
            ctx.beginPath();
            // Top Left
            ctx.moveTo(-currentSize/2, -currentSize/2 + corner);
            ctx.lineTo(-currentSize/2, -currentSize/2);
            ctx.lineTo(-currentSize/2 + corner, -currentSize/2);
            ctx.stroke();
            
            // Draw "Video Content" (Just grid lines for now)
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = label.style.color;
            ctx.fillRect(-currentSize/2 + 10, -currentSize/2 + 10, currentSize - 20, currentSize - 20);
            ctx.globalAlpha = 1.0;
            
            ctx.restore();

            // D. The Target Reticle (Visual Feedback of Hand Position)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(sx, sy, 30, 0, Math.PI*2);
            ctx.stroke();
            // Crosshairs
            ctx.beginPath();
            ctx.moveTo(sx - 40, sy); ctx.lineTo(sx + 40, sy);
            ctx.moveTo(sx, sy - 40); ctx.lineTo(sx, sy + 40);
            ctx.stroke();

            requestAnimationFrame(animate);
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        
        startCamera();
    </script>
</body>
</html>