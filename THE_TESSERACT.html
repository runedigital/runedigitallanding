<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RUNE // TESSERACT [4D_PROJECTION]</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #050505; }
  </style>
</head>
<body>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // 1. SETUP
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x050505);
    document.body.appendChild(renderer.domElement);

    // 2. THE 4D MATH
    // A Tesseract has 16 vertices. (±1, ±1, ±1, ±1)
    let points = [];
    for (let i = 0; i < 16; i++) {
      points.push([
        (i & 1) ? 1 : -1,
        (i & 2) ? 1 : -1,
        (i & 4) ? 1 : -1,
        (i & 8) ? 1 : -1
      ]);
    }

    // Connections (Edges) - A Tesseract has 32 edges.
    // We figure out which points are connected (differ by exactly 1 bit)
    const edges = [];
    for (let i = 0; i < 16; i++) {
      for (let j = i + 1; j < 16; j++) {
        // Hamming distance calculation
        let diff = 0;
        let x = i ^ j; // XOR
        while (x) {
          diff += x & 1;
          x >>= 1;
        }
        if (diff === 1) edges.push([i, j]);
      }
    }

    // 3. THREE.JS GEOMETRY
    // We will update the positions of this geometry every frame
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(edges.length * 2 * 3); // 32 edges * 2 points * 3 coords (xyz)
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // Material - Neon Cyan/Blue
    const material = new THREE.LineBasicMaterial({ 
      color: 0x00ffff, 
      opacity: 0.8, 
      transparent: true,
      linewidth: 2 
    });

    const lineSegments = new THREE.LineSegments(geometry, material);
    scene.add(lineSegments);

    // Glow Effect (Simple trick: Add a clone with thicker lines and lower opacity)
    const glowMaterial = new THREE.LineBasicMaterial({ 
      color: 0x0088aa, 
      opacity: 0.3, 
      transparent: true, 
      linewidth: 5 
    });
    const glowLines = new THREE.LineSegments(geometry, glowMaterial);
    scene.add(glowLines);


    // 4. MATRIX OPERATIONS
    function multiplyMatrixVector(m, v) {
      // Simple matrix mult for 4D vectors
      // For this demo, we only need rotation matrices which are cleaner
      // We'll implement the rotation logic directly in the loop for speed
      return v; 
    }

    let angle = 0;

    // 5. RENDER LOOP
    function animate() {
      requestAnimationFrame(animate);

      angle += 0.02;

      // Rotation Matrices
      // We rotate in the ZW plane and XY plane simultaneously
      const ca = Math.cos(angle);
      const sa = Math.sin(angle);

      const updatedPoints = [];

      // ROTATE 4D POINTS
      for (let i = 0; i < 16; i++) {
        let p = [...points[i]]; // Copy point

        // Rotation XW (Fourth Dimension Rotation)
        // This is what makes it look like it's turning inside out
        let x = p[0];
        let w = p[3];
        p[0] = x * ca - w * sa;
        p[3] = x * sa + w * ca;

        // Rotation XY (Standard 3D spin)
        let x2 = p[0];
        let y = p[1];
        p[0] = x2 * ca - y * sa;
        p[1] = x2 * sa + y * ca;

        // Rotation ZW (More 4D complexity)
        let z = p[2];
        let w2 = p[3];
        p[2] = z * ca - w2 * sa;
        p[3] = z * sa + w2 * ca;

        // PROJECT 4D -> 3D (Stereographic Projection)
        // The "distance" camera is from the 4D object
        let distance = 2.5;
        let wVal = 1 / (distance - p[3]); 

        let projectionMatrix = [
          [wVal, 0, 0],
          [0, wVal, 0],
          [0, 0, wVal]
        ];

        let projected3D = [
          p[0] * wVal,
          p[1] * wVal,
          p[2] * wVal
        ];

        // Scale it up so we can see it
        projected3D[0] *= 3;
        projected3D[1] *= 3;
        projected3D[2] *= 3;

        updatedPoints.push(projected3D);
      }

      // UPDATE GEOMETRY
      const posAttribute = geometry.attributes.position;
      let index = 0;

      for (let i = 0; i < edges.length; i++) {
        const startPoint = updatedPoints[edges[i][0]];
        const endPoint = updatedPoints[edges[i][1]];

        // Set Start
        posAttribute.setXYZ(index++, startPoint[0], startPoint[1], startPoint[2]);
        // Set End
        posAttribute.setXYZ(index++, endPoint[0], endPoint[1], endPoint[2]);
      }

      posAttribute.needsUpdate = true;

      // Slight Camera Movement
      camera.rotation.z = Math.sin(angle * 0.5) * 0.1;

      renderer.render(scene, camera);
    }

    animate();

    // RESIZE
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>