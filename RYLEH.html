<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RUNE // R'LYEH PROTOCOL</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #ui {
            position: absolute; bottom: 20px; left: 20px; color: #00ff66;
            text-shadow: 0 0 10px #00ff66; pointer-events: none;
        }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="ui">
        SUBJECT: CTHULHU_FRACTAL<br>
        GEOMETRY: NON-EUCLIDEAN<br>
        SANITY: <span id="sanity">100%</span>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // 1. SETUP
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. THE ELDRITCH SHADER
        const fragmentShader = `
            uniform float iTime;
            uniform vec2 iResolution;
            uniform vec2 iMouse;

            // Rotation Matrix
            mat2 rot(float a) {
                float s = sin(a), c = cos(a);
                return mat2(c, -s, s, c);
            }

            // THE FRACTAL FORMULA (The Monster)
            float map(vec3 p) {
                vec3 z = p;
                float d = 1000.0;
                float s = 1.0;
                
                // Breathe
                z.xz *= rot(iTime * 0.05);
                
                // Iterative Folding (Making the Tentacles)
                for(int i=0; i<6; i++) {
                    z = abs(z) - vec3(1.0, 4.0, 1.0); // Fold Space
                    z.xy *= rot(0.5); // Twist
                    z.xz *= rot(0.3 + iTime*0.1); // Writhe
                    
                    // Scale (Fractalize)
                    z *= 1.4;
                    s *= 1.4;
                    
                    // The Shape
                    // A mix of Box and Cylinder logic warped by iteration
                    d = min(d, (length(z.xz) - 0.5) / s);
                }
                
                return d;
            }

            void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
                vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;
                vec2 m = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;

                // Camera setup (Looking into the abyss)
                vec3 ro = vec3(0.0, 0.0, -8.0);
                vec3 rd = normalize(vec3(uv, 1.5));

                // Mouse Interaction (Warping reality)
                ro.z += m.y * 5.0;
                rd.xy *= rot(m.x * 0.5);

                // RAYMARCHING LOOP
                float t = 0.0;
                vec3 col = vec3(0.0);
                float glow = 0.0;

                for(int i=0; i<80; i++) {
                    vec3 p = ro + rd * t;
                    float d = map(p);
                    
                    // VOLUMETRIC GLOW (The "Slime")
                    // We accumulate light as we pass close to geometry
                    glow += 0.015 / (0.01 + abs(d));
                    
                    if(d < 0.001 || t > 20.0) break;
                    t += d * 0.5; // Slow march for precision
                }

                // COLOR PALETTE (The Deep)
                vec3 deepGreen = vec3(0.0, 0.2, 0.1);
                vec3 horrorPurple = vec3(0.1, 0.0, 0.2);
                
                // Base color based on depth
                col = mix(deepGreen, horrorPurple, t * 0.1);
                
                // Add the glow
                col += vec3(0.0, 0.5, 0.2) * glow * 0.05;
                
                // Fog (Fade to black)
                col = mix(col, vec3(0.0), 1.0 - exp(-0.1 * t));

                fragColor = vec4(col, 1.0);
            }

            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        `;

        const geometry = new THREE.PlaneGeometry(2, 2);
        const uniforms = {
            iTime: { value: 0 },
            iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            iMouse: { value: new THREE.Vector2(0, 0) }
        };

        const material = new THREE.ShaderMaterial({
            fragmentShader: fragmentShader,
            uniforms: uniforms
        });

        scene.add(new THREE.Mesh(geometry, material));

        // 3. ANIMATION LOOP
        const clock = new THREE.Clock();
        const sanityEl = document.getElementById('sanity');

        function animate() {
            requestAnimationFrame(animate);
            uniforms.iTime.value = clock.getElapsedTime();
            
            // Sanity Drop
            let s = Math.max(0, 100 - clock.getElapsedTime() * 2);
            sanityEl.innerText = Math.floor(s) + "%";
            if(s < 20) sanityEl.style.color = 'red';

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
        });

        window.addEventListener('mousemove', (e) => {
            uniforms.iMouse.value.set(e.clientX, window.innerHeight - e.clientY);
        });

    </script>
</body>
</html>