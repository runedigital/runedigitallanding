<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NEURAL // HUB</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;800&display=swap');

        body { margin: 0; overflow: hidden; background: #00050a; font-family: 'JetBrains Mono', monospace; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        #title-container { position: absolute; top: 30px; width: 100%; text-align: center; pointer-events: none; z-index: 20; mix-blend-mode: screen; }
        .glitch-text { font-size: 24px; font-weight: 800; letter-spacing: 6px; color: #00ffea; text-shadow: 0 0 10px rgba(0, 255, 234, 0.5); }
        .rune-mode { color: #ff0055 !important; text-shadow: 0 0 20px #ff0055, 2px 0 #fff !important; }
        .ghost-text { color: #333 !important; opacity: 0.3; text-shadow: none !important; }
        .label { position: absolute; color: #00ffea; font-size: 10px; background: rgba(0,0,0,0.7); padding: 2px 6px; border: 1px solid #00ffea; transform: translate(-50%, -50%); opacity: 0; transition: opacity 0.2s; }
        .label.classified { color: #555; border-color: #555; letter-spacing: 2px; }
        #loading { position: absolute; bottom: 20px; left: 20px; color: #00ffea; font-size: 12px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.3; } }
        #back-btn { position: absolute; top: 20px; left: 20px; color: #00ffea; border: 1px solid #00ffea; background: rgba(0,0,0,0.8); padding: 10px 20px; cursor: pointer; pointer-events: auto; z-index: 100; font-family: monospace; text-decoration: none; font-size: 12px; }
        #back-btn:hover { background: #00ffea; color: #000; }
        #operator-status { position: absolute; bottom: 20px; right: 20px; font-size: 11px; color: #444; letter-spacing: 1px; cursor: pointer; pointer-events: auto; z-index: 100; transition: color 0.3s; }
        #operator-status:hover { color: #00ffea; }
        #operator-status span { color: #00ff44; animation: pulse 2s infinite; }
        @keyframes pulse { 50% { opacity: 0.3; } }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

    <a href="index.html" id="back-btn">&lt; DISCONNECT</a>
    <div id="title-container"><span id="main-title" class="glitch-text">NEURAL // HUB</span></div>

    <!-- ENTER YOUR EMAIL HERE -->
    <div id="operator-status" onclick="window.location.href='mailto:sales@runedigitalstudio.com?subject=RUNE_CONTRACT_INQUIRY'">
        OPERATOR: <span>ONLINE</span> // [ AVAILABLE_FOR_CONTRACT ]
    </div>

    <div id="ui"><div id="loading">SYSTEM // MAPPING TOPOLOGY...</div></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        const titleEl = document.getElementById('main-title');
        const originalText = "NEURAL // HUB";
        function triggerGlitch() {
            let count = 0; const max = 10;
            const interval = setInterval(() => {
                const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                titleEl.innerText = originalText.split('').map(c => chars[Math.floor(Math.random() * chars.length)]).join('');
                count++;
                if (count > max) {
                    clearInterval(interval);
                    titleEl.innerHTML = `<span class="rune-mode">RUNE</span><span class="ghost-text">AL // HUB</span>`;
                    setTimeout(() => { titleEl.innerText = "N3UR4L // H_B"; setTimeout(() => { titleEl.className = "glitch-text"; titleEl.innerText = originalText; }, 100); }, 2000);
                }
            }, 50);
        }
        setInterval(triggerGlitch, 6000);
        titleEl.addEventListener('mouseenter', triggerGlitch);

        // --- THE FILE SYSTEM ---
        const fileSystem = {
            name: "ROOT", type: "folder", children: [
                { name: "OPERATOR_PROFILE.html", type: "file", url: "OPERATOR.html" },
                { 
                    name: "APPLICATIONS", type: "folder", children: [
                        { name: "CMD_SCHOOL.html", type: "app", url: "CMD_SCHOOL.html" },
                        { name: "THE_COMPILER.html", type: "app", url: "THE_COMPILER.html" },
                        { name: "COMPOUND_REACTOR.html", type: "app", url: "COMPOUND_REACTOR.html" }
                    ]
                },
                { 
                    name: "EXPERIMENTS", type: "folder", children: [
                        { name: "CHAOS_THEORY.html", type: "file", url: "CHAOS_THEORY.html" },
                        { name: "ENTANGLEMENT.html", type: "file", url: "ENTANGLEMENT.html" },
                        { name: "EVENT_HORIZON.html", type: "file", url: "EVENT_HORIZON.html" },
                        { name: "MULTIVERSE.html", type: "file", url: "MULTIVERSE.html" }
                    ]
                },
                { 
                    name: "THEORY", type: "folder", children: [
                        { name: "HYPER.html", type: "file", url: "HYPER.html" },
                        { name: "THE_GOD_FRACTAL.html", type: "file", url: "THE_GOD_FRACTAL.html" },
                        { name: "THE_TESSERACT.html", type: "file", url: "THE_TESSERACT.html" },
                        { name: "VIVALDI_MASTER.html", type: "file", url: "VIVALDI_MASTER.html" }
                    ]
                },
                { 
                    name: "R_AND_D", type: "folder", children: [
                        { name: "PROJECT_KINETIC [CLASSIFIED]", type: "classified", url: null },
                        { name: "RUNE_OS_KERNEL [OFFLINE]", type: "classified", url: null }
                    ]
                }
            ]
        };

        const scene = new THREE.Scene(); scene.background = new THREE.Color(0x00050a);
        scene.fog = new THREE.FogExp2(0x00050a, 0.002);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 20);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05;
        controls.minDistance = 5; controls.maxDistance = 100;

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloom.threshold = 0.1; bloom.strength = 1.2; bloom.radius = 0.5;
        composer.addPass(bloom);

        const folderGeo = new THREE.IcosahedronGeometry(1, 1);
        const appGeo = new THREE.OctahedronGeometry(0.6, 0); 
        const fileGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const classGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);

        const mats = {
            folder: new THREE.MeshBasicMaterial({ color: 0x00ffea, wireframe: true }),
            app: new THREE.MeshBasicMaterial({ color: 0xffcc00, wireframe: true }), 
            file: new THREE.MeshBasicMaterial({ color: 0xff0055, wireframe: true }),
            classified: new THREE.MeshBasicMaterial({ color: 0x333333, wireframe: true }),
            line: new THREE.LineBasicMaterial({ color: 0x0044aa, transparent: true, opacity: 0.3 })
        };

        const nodes = [];

        function build(data, parent=null) {
            const node = { ...data, id: Math.random(), position: new THREE.Vector3(), mesh: null };
            if(parent) {
                const r = (data.type === 'folder' ? 10 : 5) + Math.random()*3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                node.position.set(parent.position.x + r * Math.sin(phi) * Math.cos(theta), parent.position.y + r * Math.sin(phi) * Math.sin(theta), parent.position.z + r * Math.cos(phi));
            }
            let geo = fileGeo; let mat = mats.file;
            if (data.type === 'folder') { geo = folderGeo; mat = mats.folder; }
            else if (data.type === 'app') { geo = appGeo; mat = mats.app; }
            else if (data.type === 'classified') { geo = classGeo; mat = mats.classified; }
            
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(node.position);
            mesh.userData = { node: node };
            scene.add(mesh);
            node.mesh = mesh;
            nodes.push(node);

            const div = document.createElement('div');
            div.className = 'label';
            if(data.type === 'classified') div.className += ' classified';
            div.textContent = data.name;
            document.getElementById('ui').appendChild(div);
            node.el = div;

            if(parent) {
                const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([parent.position, node.position]), mats.line);
                scene.add(line);
            }
            if(data.children) data.children.forEach(c => build(c, node));
        }
        build(fileSystem);
        document.getElementById('loading').textContent = "SYSTEM // ONLINE";

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        window.addEventListener('mousemove', e => { mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1; });
        window.addEventListener('dblclick', () => {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes.map(n => n.mesh));
            if(intersects.length > 0) {
                const target = intersects[0].object.userData.node;
                if(target.url) window.location.href = target.url;
                else if(target.type === 'classified') alert("SYSTEM ALERT: MAINTENANCE MODE.\n\nThis node is currently offline pending configuration.");
            }
        });

        function animate() {
            requestAnimationFrame(animate); controls.update();
            nodes.forEach(n => {
                n.mesh.rotation.y += 0.01; if(n.type === 'app') n.mesh.rotation.x += 0.02;
                const v = n.position.clone().project(camera);
                const x = (v.x * .5 + .5) * window.innerWidth; const y = (v.y * -.5 + .5) * window.innerHeight;
                if(v.z < 1 && camera.position.distanceTo(n.position) < 60) { 
                    n.el.style.transform = `translate(-50%,-50%) translate(${x}px,${y}px)`; 
                    n.el.style.opacity = 1; 
                } else { n.el.style.opacity = 0; }
            });
            composer.render();
        }
        animate();
    </script>
</body>
</html>