<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RUNE // EVENT HORIZON</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: #ff0055;
            pointer-events: none; z-index: 10; mix-blend-mode: difference;
        }
        .stat { font-weight: bold; font-size: 14px; color: #fff; }
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff0055; font-size: 20px; animation: blink 0.2s infinite; pointer-events: none;
        }
        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>

    <div id="ui">
        // SYSTEM: EVENT HORIZON<br>
        // ENTITIES: <span class="stat">500,000</span><br>
        // POLYGONS: <span class="stat">6,000,000</span><br>
        // PHYSICS: <span class="stat">ORBITAL SHADER</span>
    </div>

    <div id="loader">:: COLLAPSING STAR ::</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- STRESS LEVEL: CRITICAL ---
        const INSTANCE_COUNT = 500000; 
        const GALAXY_RADIUS = 150;

        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 40, 60); // High angle view

        const renderer = new THREE.WebGLRenderer({ 
            antialias: false, 
            powerPreference: "high-performance",
            stencil: false,
            depth: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1); // Force 1:1 pixel ratio for raw performance
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.2;

        // --- THE ORBITAL SHADER ---
        const vertexShader = `
            uniform float time;
            uniform vec3 mouse;
            
            attribute vec3 aOffset;   // Initial Position (Angle, Radius, Height)
            attribute vec3 aColor;
            attribute float aSpeed;   // Orbital Velocity
            attribute float aSize;    // Random Size

            varying vec3 vColor;
            varying float vDist;

            // Rotation Matrix function
            mat2 rotate2D(float angle) {
                return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
            }

            void main() {
                vColor = aColor;

                // UNPACKING DATA
                // aOffset.x = Initial Angle
                // aOffset.y = Radius (Distance from center)
                // aOffset.z = Height (Thickness of disk)
                
                float angle = aOffset.x;
                float radius = aOffset.y;
                float height = aOffset.z;

                // PHYSICS: KEPLER'S LAW APPROXIMATION
                // Objects closer to center move faster
                float currentAngle = angle + (time * aSpeed * (50.0 / radius));
                
                // Calculate World Position
                float x = cos(currentAngle) * radius;
                float z = sin(currentAngle) * radius;
                float y = height;

                // MOUSE GRAVITY (Warping space)
                vec3 particlePos = vec3(x, y, z);
                float distToMouse = distance(particlePos, mouse);
                float warpRadius = 30.0;

                if(distToMouse < warpRadius) {
                    // Push particles down/up based on mouse proximity (Gravity Wave)
                    particlePos.y += sin(distToMouse) * 5.0;
                }

                // Apply the size and shape
                vec3 finalPos = position * aSize + particlePos;

                vDist = radius; // Pass radius to fragment shader for coloring
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            varying float vDist;

            void main() {
                // Make center hotter (whiter)
                float intensity = 1.0;
                if(vDist < 20.0) intensity = 2.0;

                gl_FragColor = vec4(vColor * intensity, 1.0);
            }
        `;

        // --- GEOMETRY GENERATION ---
        // We use a Tetrahedron (4 faces) to save polygons. 
        // At 500k instances, you can't tell it's a pyramid.
        const geometry = new THREE.TetrahedronGeometry(0.08, 0); 
        
        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                mouse: { value: new THREE.Vector3(0, 0, 0) }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        const mesh = new THREE.InstancedMesh(geometry, material, INSTANCE_COUNT);

        // --- DATA FILL ---
        const offsets = new Float32Array(INSTANCE_COUNT * 3);
        const colors = new Float32Array(INSTANCE_COUNT * 3);
        const speeds = new Float32Array(INSTANCE_COUNT);
        const sizes = new Float32Array(INSTANCE_COUNT);

        const _color = new THREE.Color();

        for (let i = 0; i < INSTANCE_COUNT; i++) {
            // Spiral Distribution
            const radius = Math.random() * GALAXY_RADIUS + 5.0; // Minimum distance 5.0
            const angle = Math.random() * Math.PI * 2;
            
            // Gaussian distribution for height (flat disk)
            const u = Math.random();
            const v = Math.random();
            const height = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v) * 2.0;

            offsets[i * 3] = angle;     // Store Angle in X
            offsets[i * 3 + 1] = radius; // Store Radius in Y
            offsets[i * 3 + 2] = height; // Store Height in Z

            // Color Gradient based on radius
            if(radius < 20) {
                _color.setHex(0xffaa00); // Core: Gold/White
            } else if (radius < 60) {
                _color.setHex(0xff0055); // Inner: Red/Pink
            } else {
                _color.setHex(0x5500ff); // Outer: Purple/Blue
            }

            colors[i * 3] = _color.r;
            colors[i * 3 + 1] = _color.g;
            colors[i * 3 + 2] = _color.b;

            speeds[i] = Math.random() * 0.5 + 0.2;
            sizes[i] = Math.random() * 1.0 + 0.5;
        }

        geometry.setAttribute('aOffset', new THREE.InstancedBufferAttribute(offsets, 3));
        geometry.setAttribute('aColor', new THREE.InstancedBufferAttribute(colors, 3));
        geometry.setAttribute('aSpeed', new THREE.InstancedBufferAttribute(speeds, 1));
        geometry.setAttribute('aSize', new THREE.InstancedBufferAttribute(sizes, 1));

        scene.add(mesh);
        document.getElementById('loader').style.display = 'none';

        // --- MOUSE INTERACTION ---
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const planeGeo = new THREE.PlaneGeometry(300, 300);
        const plane = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({visible: false}));
        plane.rotation.x = -Math.PI / 2; // Flat plane
        scene.add(plane);

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(plane);
            
            if (intersects.length > 0) {
                material.uniforms.mouse.value.copy(intersects[0].point);
            }
        }
        window.addEventListener('mousemove', onMouseMove);

        // --- RENDER LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            material.uniforms.time.value = time;
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>