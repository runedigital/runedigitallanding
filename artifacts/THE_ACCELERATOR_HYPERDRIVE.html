<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RUNE // ACCELERATOR [CYLINDRICAL]</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Share Tech Mono', monospace;
            cursor: none !important; 
        }

        #hud {
            position: absolute; top: 20px; left: 20px; color: #00ffea;
            pointer-events: none; z-index: 10;
            text-shadow: 0 0 5px #00ffea;
        }
        
        .speed-bar {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 4px; background: #333;
        }
        #speed-fill {
            width: 0%; height: 100%; background: #00ffea;
            box-shadow: 0 0 10px #00ffea; transition: width 0.1s;
        }

        #cursor-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; pointer-events: none;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="hud">
        SYSTEM: PROPULSION_ONLINE<br>
        PARTICLES: 40,000<br>
        DISTRIBUTION: CYLINDRICAL<br>
        STATUS: <span id="status-text">IDLE</span>
    </div>

    <div class="speed-bar"><div id="speed-fill"></div></div>
    <canvas id="cursor-layer"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // 1. SETUP
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0005);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        camera.position.z = 1000;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const cCanvas = document.getElementById('cursor-layer');
        const ctx = cCanvas.getContext('2d');

        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 1.5;
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // 2. CYLINDRICAL PARTICLE SYSTEM
        const particleCount = 40000; 
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];

        const radius = 4000; // How wide is the tube
        const depth = 6000;  // How deep is the tube

        const color1 = new THREE.Color(0x00ffea); 
        const color2 = new THREE.Color(0xffffff); 

        for (let i = 0; i < particleCount; i++) {
            // POLAR COORDINATES (The fix for the box shape)
            // We generate a random angle and a random distance from center
            const r = Math.random() * radius; 
            const theta = Math.random() * Math.PI * 2;
            
            const x = r * Math.cos(theta);
            const y = r * Math.sin(theta);
            const z = (Math.random() * depth) - 3000; // Random Z depth

            positions.push(x, y, z);

            const mixedColor = color1.clone().lerp(color2, Math.random());
            colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
            sizes.push(Math.random() * 2);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        const material = new THREE.PointsMaterial({
            size: 3, vertexColors: true, blending: THREE.AdditiveBlending,
            depthTest: false, transparent: true, opacity: 0.8
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // 3. VARS
        let mouseX = 0, mouseY = 0;
        let targetX = 0, targetY = 0;
        let speed = 5;
        let targetSpeed = 5;
        let isWarping = false;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX - window.innerWidth / 2;
            mouseY = e.clientY - window.innerHeight / 2;
        });
        document.addEventListener('mousedown', () => { isWarping = true; });
        document.addEventListener('mouseup', () => { isWarping = false; });

        function resize() {
            const w = window.innerWidth; const h = window.innerHeight;
            camera.aspect = w / h; camera.updateProjectionMatrix();
            renderer.setSize(w, h); composer.setSize(w, h);
            cCanvas.width = w; cCanvas.height = h;
        }
        window.addEventListener('resize', resize);
        resize();

        // 4. CURSOR
        let cx = window.innerWidth/2, cy = window.innerHeight/2; 
        let rot = 0;

        function drawCursor() {
            ctx.clearRect(0, 0, cCanvas.width, cCanvas.height);
            const mx = mouseX + window.innerWidth/2;
            const my = mouseY + window.innerHeight/2;
            cx += (mx - cx) * 0.2; cy += (my - cy) * 0.2; rot += 0.05;

            const color = isWarping ? '#ff0055' : '#00ffea';
            ctx.strokeStyle = color; ctx.lineWidth = 2;
            ctx.shadowBlur = 10; ctx.shadowColor = color;

            ctx.save(); ctx.translate(cx, cy);
            ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(8, 10); ctx.lineTo(-8, 10); ctx.closePath(); ctx.stroke();
            ctx.rotate(rot);
            ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI * 1.5); ctx.stroke();
            ctx.rotate(-rot * 2);
            ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 0.5); ctx.stroke();
            ctx.rotate(Math.PI);
            ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 0.5); ctx.stroke();
            ctx.restore();
        }

        // 5. MAIN LOOP
        function animate() {
            requestAnimationFrame(animate);

            if (isWarping) {
                targetSpeed = 100; 
                document.getElementById('status-text').innerText = "HYPERDRIVE_ENGAGED";
                document.getElementById('status-text').style.color = "#ff0055";
            } else {
                targetSpeed = 5; 
                document.getElementById('status-text').innerText = "CRUISING";
                document.getElementById('status-text').style.color = "#00ffea";
            }

            speed += (targetSpeed - speed) * 0.05;
            const pct = Math.min(speed, 100);
            document.getElementById('speed-fill').style.width = pct + '%';
            document.getElementById('speed-fill').style.backgroundColor = isWarping ? '#ff0055' : '#00ffea';

            const targetFOV = isWarping ? 120 : 75;
            camera.fov += (targetFOV - camera.fov) * 0.05;
            camera.updateProjectionMatrix();

            // PARTICLE PHYSICS
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3 + 2] += speed;

                // Respawn check
                if (positions[i * 3 + 2] > 1000) {
                    // Send back to start
                    // Respawn in a range to prevent "sheets" of stars
                    positions[i * 3 + 2] = -3000 - (Math.random() * 1000); 
                    
                    // Respawn X/Y in CYLINDER (Polar coordinates)
                    const r = Math.random() * radius; 
                    const theta = Math.random() * Math.PI * 2;
                    
                    positions[i * 3] = r * Math.cos(theta);     // X
                    positions[i * 3 + 1] = r * Math.sin(theta); // Y
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;

            targetX = mouseX * 0.001; targetY = mouseY * 0.001;
            particles.rotation.y += 0.0005; 
            particles.rotation.z += (targetX - particles.rotation.z) * 0.05;
            particles.rotation.x += (targetY - particles.rotation.x) * 0.05;

            composer.render();
            drawCursor();
        }

        animate();

    </script>
</body>
</html>