<!DOCTYPE html><html lang="en"> <head>   <meta charset="UTF-8">   <title>RUNE // VIVALDI PROTOCOL</title>   <style>     body { margin: 0; overflow: hidden; background: #050505; font-family: monospace; }           /* START OVERLAY */     #overlay {       position: fixed; top: 0; left: 0; width: 100%; height: 100%;       background: rgba(0,0,0,0.9); z-index: 10;       display: flex; flex-direction: column; justify-content: center; align-items: center;       cursor: pointer;       transition: opacity 0.8s ease;     }           h1 { color: #d4af37; letter-spacing: 5px; font-size: 2rem; margin-bottom: 10px; text-transform: uppercase; }     p { color: #666; font-size: 0.8rem; letter-spacing: 2px; }           .hidden { opacity: 0; pointer-events: none; }   </style>       <script type="importmap">     { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }   </script> </head> <body>
<div id="overlay" onclick="startAudio()">
    <h1>Vivaldi Protocol</h1>
    <p>[ CLICK TO SYNC AUDIO ]</p>
  </div>

<script type="module">
    import * as THREE from 'three';

// 1. SETUP SCENE
    const scene = new THREE.Scene();
    // Add slight fog for depth
    scene.fog = new THREE.FogExp2(0x050505, 0.002);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    // Tilted camera angle for better 3D view of the spikes
    camera.position.set(0, -80, 120);
    camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

// 2. THE GEOMETRY
    const count = 2500; // Increased density for richer visuals
    const geometry = new THREE.BoxGeometry(1, 1, 10); // Long thin boxes
    const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const mesh = new THREE.InstancedMesh(geometry, material, count);
     
    const dummy = new THREE.Object3D();
    const color = new THREE.Color();
    const goldenAngle = 137.508;

// Initialize flat spiral
    for (let i = 0; i < count; i++) {
      const angle = i * goldenAngle * (Math.PI / 180);
      const radius = 3.5 * Math.sqrt(i); // Spread them out a bit more
       
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);
      const z = 0;

dummy.position.set(x, y, z);
      dummy.lookAt(0, 0, 0);
      dummy.updateMatrix();
      mesh.setMatrixAt(i, dummy.matrix);
      mesh.setColorAt(i, new THREE.Color(0x333333));
    }

scene.add(mesh);

// 3. AUDIO SYSTEM
    let analyser, dataArray;
    let audioActive = false;

window.startAudio = async () => {
      document.getElementById('overlay').classList.add('hidden');
       
      try {
       const stream = await navigator.mediaDevices.getUserMedia({ 
  audio: {
    echoCancellation: false,
    autoGainControl: false, // THE KEY
    noiseSuppression: false,
    latency: 0
  } 
});
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioCtx.createMediaStreamSource(stream);
         
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048; 
        source.connect(analyser);
         
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        audioActive = true;
      } catch (err) {
        alert("Microphone access required for visualization.");
      }
    };

// 4. ANIMATION LOOP
    const clock = new THREE.Clock();

function animate() {
      requestAnimationFrame(animate);
       
      const time = clock.getElapsedTime();

// Auto-Camera Pan (Cinematic Movement)
      // Slowly rotates around the center so you don't need to move the mouse
      camera.position.x = Math.sin(time * 0.1) * 20;
      camera.position.y = -80 + Math.cos(time * 0.15) * 10;
      camera.lookAt(0, 0, 0);

// Rotate the spiral itself slightly
      mesh.rotation.z -= 0.001;

if (audioActive) {
        analyser.getByteFrequencyData(dataArray);
         
       for (let i = 0; i < count; i++) {
          // 1. FREQUENCY MAPPING
          const freqIndex = Math.floor((i / count) * 600); 
          const rawVal = dataArray[freqIndex] || 0;

// 2. COMPRESSION / GAIN STAGE
          // We multiply raw input by 1.8 (Gain). 
          // This ensures quiet notes hit harder.
          // We clamp it at 1.0 so it doesn't glitch out.
          let input = Math.min((rawVal / 255) * 0.7
, 1.0);

// 3. SOFTER CURVE
          // Changed from 1.8 to 1.2. 
          // This lets the "mids" and "lows" show up clearly.
          const value = Math.pow(input, 1.2) * 255;

// 4. POSITIONING
          const angle = i * goldenAngle * (Math.PI / 180);
          const radius = 3.5 * Math.sqrt(i);
          const x = radius * Math.cos(angle);
          const y = radius * Math.sin(angle);
           
          // 5. DYNAMIC HEIGHT + IDLE BREATH
          // We add a small sine wave based on time so it breathes even in silence
          // Plus the audio reactivity
          const idle = Math.sin((time * 2) + (i * 0.1)) * 5; 
          const z = idle + ((value / 255) * 60); 
           
          dummy.position.set(x, y, z);
          dummy.lookAt(0, 0, 0);
           
          // 6. SCALE
          // Base scale is 0.5 (thicker) so they don't disappear
          const scale = 0.5 + (value / 255) * 7
          dummy.scale.set(1, 1, scale);
           
          dummy.updateMatrix();
          mesh.setMatrixAt(i, dummy.matrix);

// 7. COLOR
          const intensity = value / 255;
          color.setHSL(0.11, 1.0, 0.1 + (intensity * 0.8)); // Base brightness up to 0.1
          mesh.setColorAt(i, color);
        }
         
        mesh.instanceMatrix.needsUpdate = true;
        mesh.instanceColor.needsUpdate = true;
      }

renderer.render(scene, camera);
    }

animate();

// RESIZE HANDLER
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>

</body> </html> There's my settings I landed on FYI