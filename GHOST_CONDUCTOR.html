<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RUNE // GHOST CONDUCTOR v1.3</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        #status-log {
            color: #00ffea; font-size: 12px; opacity: 0.8; text-shadow: 0 0 5px #00ffea;
        }

        #controls {
            align-self: center; pointer-events: auto; margin-bottom: 50px;
        }

        .btn {
            background: rgba(0, 255, 234, 0.1); border: 1px solid #00ffea; color: #00ffea;
            padding: 15px 30px; font-family: inherit; font-weight: bold; cursor: pointer;
            text-transform: uppercase; letter-spacing: 2px; transition: 0.3s;
            backdrop-filter: blur(5px);
        }
        .btn:hover { background: #00ffea; color: #000; box-shadow: 0 0 20px #00ffea; }
        
        #input-video { display: none; }
    </style>
</head>
<body>

    <video id="input-video"></video>

    <div id="ui-layer">
        <div id="status-log">
            // RUNE DIGITAL v1.3<br>
            // SYSTEM: GHOST CONDUCTOR<br>
            // SIGNAL: WAITING...
        </div>
        <div id="controls">
            <button id="init-btn" class="btn" onclick="startBioLink()">[ INITIALIZE BIO-LINK ]</button>
        </div>
    </div>

    <!-- IMPORT THREE.JS -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- IMPORT MEDIAPIPE -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // LIGHTS
        const pLight1 = new THREE.PointLight(0x00ffea, 100, 50);
        pLight1.position.set(5, 5, 5);
        scene.add(pLight1);
        
        const pLight2 = new THREE.PointLight(0xff0055, 100, 50);
        pLight2.position.set(-5, 5, -5);
        scene.add(pLight2);

        // LIQUID MESH
        const geo = new THREE.PlaneGeometry(20, 20, 48, 48);
        const mat = new THREE.MeshStandardMaterial({ 
            color: 0x111111, roughness: 0.2, metalness: 0.9, 
            wireframe: true, emissive: 0x00ffea, emissiveIntensity: 0.1 
        });
        const plane = new THREE.Mesh(geo, mat);
        plane.rotation.x = -Math.PI / 2;
        scene.add(plane);

        // GHOST HAND SETUP
        const handGroup = new THREE.Group();
        handGroup.renderOrder = 999;
        scene.add(handGroup);
        
        const jointGeo = new THREE.SphereGeometry(0.15, 8, 8); 
        const jointMat = new THREE.MeshBasicMaterial({ 
            color: 0xff0055, 
            wireframe: true,
            depthTest: false,
            transparent: true,
            opacity: 0 // Start invisible
        });
        
        const joints = [];
        const targetPositions = []; 

        for(let i=0; i<21; i++) {
            const m = new THREE.Mesh(jointGeo, jointMat.clone()); // Clone material so we can fade individual parts if needed (or global)
            joints.push(m);
            handGroup.add(m);
            targetPositions.push(new THREE.Vector3(0,0,0));
        }

        // --- VARIABLES ---
        let time = 0;
        let waveHeight = 0.5;
        let targetWaveHeight = 0.5;
        let pinchActive = false;
        let lastFrameTime = 0;
        
        // Tracking Logic
        let isTracking = false;
        let globalOpacity = 0;

        const status = document.getElementById('status-log');
        const initBtn = document.getElementById('init-btn');

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.04;

            // FADE LOGIC: Smoothly fade hand in/out based on tracking status
            const targetOpacity = isTracking ? 0.8 : 0;
            globalOpacity = THREE.MathUtils.lerp(globalOpacity, targetOpacity, 0.1);
            
            // Apply movement and opacity
            for(let i=0; i<21; i++) {
                // Move visual joints
                joints[i].position.lerp(targetPositions[i], 0.25); 
                joints[i].rotation.x += 0.02;
                joints[i].rotation.y += 0.02;
                
                // Update Opacity
                joints[i].material.opacity = globalOpacity;
                
                // Optimization: If fully invisible, stop rendering them? (Optional, keeping simple for now)
                joints[i].visible = globalOpacity > 0.01;
            }

            waveHeight = THREE.MathUtils.lerp(waveHeight, targetWaveHeight, 0.1);

            // Update Liquid
            const positions = geo.attributes.position;
            for(let i=0; i<positions.count; i++){
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = Math.sin(x * 0.4 + time) * Math.cos(y * 0.4 + time) * waveHeight;
                positions.setZ(i, z);
            }
            positions.needsUpdate = true;
            geo.computeVertexNormals();

            renderer.render(scene, camera);
        }
        animate();

        // --- MEDIAPIPE INTEGRATION ---
        window.startBioLink = async function() {
            initBtn.innerText = "INITIALIZING...";
            initBtn.disabled = true;
            status.innerHTML += "<br>// LOADING MODELS...";

            const videoElement = document.getElementById('input-video');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.4, // Easier to catch
                minTrackingConfidence: 0.6   // Harder to lose
            });

            hands.onResults(onResults);

            const cameraObj = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            cameraObj.start()
                .then(() => {
                    initBtn.style.display = 'none';
                    status.innerHTML += "<br>// SENSOR ACTIVE.";
                })
                .catch(err => {
                    status.innerHTML += "<br>!! ERROR: ACCESS DENIED";
                    console.error(err);
                });
        };

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                isTracking = true;
                status.innerHTML = `// RUNE DIGITAL<br>// SIGNAL: <span style="color:#00ff00">LOCKED</span>`;

                // UPDATE TARGETS
                landmarks.forEach((lm, i) => {
                    const x = (lm.x - 0.5) * -12; 
                    const y = (lm.y - 0.5) * -10 + 3; 
                    const z = lm.z * -15; 
                    targetPositions[i].set(x, y, z);
                });

                // CONTROL LOGIC
                const wristY = landmarks[0].y; 
                targetWaveHeight = (1 - wristY) * 3; 
                
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const dist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

                if(dist < 0.05) {
                    if(!pinchActive) {
                        mat.emissive.setHex(0xff0055); 
                        pinchActive = true;
                    }
                } else {
                    if(pinchActive) {
                        mat.emissive.setHex(0x00ffea);
                        pinchActive = false;
                    }
                }

            } else {
                isTracking = false;
                status.innerHTML = `// RUNE DIGITAL<br>// SIGNAL: <span style="color:#ff0055">SEARCHING...</span>`;
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>